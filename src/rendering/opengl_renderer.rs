use std::io::{Result, Error, ErrorKind};

use glium::texture::srgb_texture2d::SrgbTexture2d;
use glium::texture::{RawImage2d, MipmapsOption};
use glium::Rect;

use crate::rendering::renderer::Renderer;

 struct OpenGLRenderer {
    display: glium::Display,
 }

 impl Renderer for OpenGLRenderer {

    fn resize_viewport(&self, width: usize, height: usize) {
        todo!()
    }

    fn clear(&self) {
        todo!()
    }

    fn create_texture(&self, mipmaps: &Vec<&crate::resource::image::Image>) -> Result<SrgbTexture2d> {
        if mipmaps.len() < 1 {
            return Err(Error::new(ErrorKind::InvalidInput, "At least one image must be provided to create a texture"));
        }
        let raw = RawImage2d::from_raw_rgba_reversed(
            &mipmaps[0].data,
            (mipmaps[0].width as u32, mipmaps[0].height as u32)
        );
        let mipmaps_option = if mipmaps.len() > 1 {
            MipmapsOption::EmptyMipmapsMax(mipmaps.len() as u32)
        } else {
            MipmapsOption::AutoGeneratedMipmaps
        };
        let texture: SrgbTexture2d = match SrgbTexture2d::with_mipmaps(&self.display, raw, mipmaps_option) {
            Ok(tex) => tex,
            Err(error) => return Err(Error::new(ErrorKind::InvalidData, format!("Unable to create level 0 mipmap: {}", error)))
        };
        if mipmaps.len() == 1 {
            return Ok(texture);
        }
        for i in 1..mipmaps.len() {
            let image: &crate::resource::image::Image = mipmaps[i];
            texture.mipmap(1).unwrap().write(
                Rect {
                    left: 0,
                    bottom: 0,
                    width: image.width as u32,
                    height: image.height as u32
                },
                RawImage2d::from_raw_rgba_reversed(
                    &image.data,
                    (image.width as u32, image.height as u32)
                )
            );
        }
        return Ok(texture);
    }

    fn create_cube_texture(&self, sides: [crate::resource::image::Image; 6]) -> Result<SrgbTexture2d> {
        todo!()
    }

    fn render_coords(&self, matrix: &glm::Mat4) {
        todo!()
    }

    fn render_skybox(&self, cubemap: &Box<dyn super::renderer::Texture>, matrix: &glm::Mat4) {
        todo!()
    }

    fn render_static(&self, entities: &Vec<super::renderer::EntityData>,
                     decals: &Vec<crate::map::bsp::Decal>,
                     static_layout: &glium::VertexBuffer<super::renderer::VertexWithLM>,
                     decal_layout: &glium::VertexBuffer<super::renderer::Vertex>,
                     textures: &Vec<Box<dyn super::renderer::Texture>>,
                     lightmaps_atlas: &Box<dyn super::renderer::Texture>,
                     settings: &super::renderable::RenderSettings) {
        todo!()
    }

    fn render_imgui(&self, data: &imgui::DrawData) {
        todo!()
    }

    fn provide_facade(&self) -> &dyn glium::backend::Facade {
        todo!()
    }

    fn screenshot(&self) -> crate::resource::image::Image {
        todo!()
    }

}
