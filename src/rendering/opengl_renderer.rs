use std::io::{Result, Error, ErrorKind};

use glium::texture::{SrgbTexture2d, SrgbCubemap, RawImage2d, MipmapsOption};
use glium::Rect;

use crate::rendering::renderer::Renderer;

 struct OpenGLRenderer {
    display: glium::Display,
 }

 impl Renderer for OpenGLRenderer {

    fn resize_viewport(&self, width: usize, height: usize) {
        todo!()
    }

    fn clear(&self) {
        todo!()
    }

    fn create_texture(&self, mipmaps: &Vec<&crate::resource::image::Image>) -> Result<SrgbTexture2d> {
        if mipmaps.len() < 1 {
            return Err(Error::new(ErrorKind::InvalidInput, "At least one image must be provided to create a texture"));
        }
        let raw = RawImage2d::from_raw_rgba_reversed(
            &mipmaps[0].data,
            (mipmaps[0].width as u32, mipmaps[0].height as u32)
        );
        let mipmaps_option = if mipmaps.len() > 1 {
            MipmapsOption::EmptyMipmapsMax(mipmaps.len() as u32)
        } else {
            MipmapsOption::AutoGeneratedMipmaps
        };
        let texture: SrgbTexture2d = match SrgbTexture2d::with_mipmaps(&self.display, raw, mipmaps_option) {
            Ok(tex) => tex,
            Err(error) => return Err(Error::new(ErrorKind::InvalidData, format!("Unable to create level 0 mipmap: {}", error)))
        };
        if mipmaps.len() == 1 {
            return Ok(texture);
        }
        for i in 1..mipmaps.len() {
            let image: &crate::resource::image::Image = mipmaps[i];
            texture.mipmap(1).unwrap().write(
                Rect {
                    left: 0,
                    bottom: 0,
                    width: image.width as u32,
                    height: image.height as u32
                },
                RawImage2d::from_raw_rgba_reversed(
                    &image.data,
                    (image.width as u32, image.height as u32)
                )
            );
        }
        return Ok(texture);
    }

    fn create_cube_texture(&self, sides: [crate::resource::image::Image; 6]) -> Result<SrgbCubemap> {
        let cubemap: SrgbCubemap = match SrgbCubemap::empty_with_mipmaps(&self.display, MipmapsOption::AutoGeneratedMipmaps, 2) {
            Ok(tex) => tex,
            Err(error) => return Err(Error::new(ErrorKind::InvalidData, format!("Unable to create empty cubemap of dimentsion 2: {}", error))),
        };
        for i in 0..sides.len() {
            // TODO: Implement this, no direct texture binding available in glium for cubemaps,
            // need to use framebuffers to bind the textures to instead. Not sure how to handle
            // this:
            //let  framebuffer1 = glium::framebuffer::SimpleFrameBuffer::new(&display,
                            //cubemap.main_level().image(glium::texture::CubeLayer::PositiveX)).unwrap();
            //let  framebuffer2 = glium::framebuffer::SimpleFrameBuffer::new(&display,
                            //cubemap.main_level().image(glium::texture::CubeLayer::NegativeX)).unwrap();
            //let  framebuffer3 = glium::framebuffer::SimpleFrameBuffer::new(&display,
                            //cubemap.main_level().image(glium::texture::CubeLayer::PositiveY)).unwrap();
            //let  framebuffer4 = glium::framebuffer::SimpleFrameBuffer::new(&display,
                            //cubemap.main_level().image(glium::texture::CubeLayer::NegativeY)).unwrap();
            //let  framebuffer5 = glium::framebuffer::SimpleFrameBuffer::new(&display,
                            //cubemap.main_level().image(glium::texture::CubeLayer::PositiveZ)).unwrap();
            //let  framebuffer6 = glium::framebuffer::SimpleFrameBuffer::new(&display,
                            //cubemap.main_level().image(glium::texture::CubeLayer::NegativeZ)).unwrap();

            //tex_posx.as_surface().blit_whole_color_to(&framebuffer1, &dest_rect1,
                            //glium::uniforms::MagnifySamplerFilter::Linear);
            //tex_negx.as_surface().blit_whole_color_to(&framebuffer2, &dest_rect1,
                            //glium::uniforms::MagnifySamplerFilter::Linear);
            //tex_negy.as_surface().blit_whole_color_to(&framebuffer3, &dest_rect1,
                            //glium::uniforms::MagnifySamplerFilter::Linear);
            //tex_posy.as_surface().blit_whole_color_to(&framebuffer4, &dest_rect1,
                            //glium::uniforms::MagnifySamplerFilter::Linear);
            //tex_posz.as_surface().blit_whole_color_to(&framebuffer5, &dest_rect1,
                            //glium::uniforms::MagnifySamplerFilter::Linear);
            //tex_negz.as_surface().blit_whole_color_to(&framebuffer6, &dest_rect1,
                            //glium::uniforms::MagnifySamplerFilter::Linear);
        }
        todo!()
    }

    fn render_coords(&self, matrix: &glm::Mat4) {
        // TODO: Attach rest of mipmaps via: SrgbTexture2d$mipmap(u32)?$write(Rect,Texture2dDataSource)
        todo!()
    }

    fn render_skybox(&self, cubemap: &SrgbCubemap, matrix: &glm::Mat4) {
        todo!()
    }

    fn render_static(&self, entities: &Vec<super::renderer::EntityData>,
                     decals: &Vec<crate::map::bsp::Decal>,
                     static_layout: &glium::VertexBuffer<super::renderer::VertexWithLM>,
                     decal_layout: &glium::VertexBuffer<super::renderer::Vertex>,
                     textures: &Vec<SrgbTexture2d>,
                     lightmaps_atlas: &SrgbTexture2d,
                     settings: &super::renderable::RenderSettings) {
        todo!()
    }

    fn render_imgui(&self, data: &imgui::DrawData) {
        todo!()
    }

    fn provide_facade(&self) -> &dyn glium::backend::Facade {
        todo!()
    }

    fn screenshot(&self) -> crate::resource::image::Image {
        todo!()
    }

}
